前言
1.并行计算并不是在所有情况都有用武之地的, 它只有在图像处理和服务端编程有着巨大的建树.

2.很多时候, 使用并行并不是完全出自对性能的考虑, 而是建模需要使得程序更容易被理解和维护.

3.由于硬件并不能快速地进步, 想要继续进步这必须得是软件开发者付出努力,
  所以, 如何让多个CPU有效且正确地工作成为了一门技术, 甚至是很大的学问.





必须知道的概念
1.同步(synchronous)和异步(asynchronous)
  同步和异步通常用来形容一次方法调用.
  同步方法调用一旦开始, 调用者必须等待方法调用返回后才能继续后续的行为;
  异步方法调用一旦开始, 方法调用就会立即返回, 调用者就可以继续后续的操作, 它更像一个消息传递.

2.并发(concurrency)和并行(parallelism)
  并行和并发是两个很容易混淆的概念, 它们都可以表示两个或者多个任务一起执行, 但是偏重点不同.
  并发偏重于多个任务交替执行, 而多个人物之间有可能还是串行的;
  而并行是真正意义上的同时执行(但这个要看具体情况, 因为如果只有1个CPU, 那也只能是并发执行)

3.临界区(critical section)
  临界区用来表示一种可以倍多个线程使用的共享资源或者共享数据,
  但每一次, 只有1个线程可以使用它, 一旦临界区资源被占用, 其他线程想要使用这个资源, 就必须等待

4.阻塞(blocking)和非阻塞(non-blocking)
  阻塞和非阻塞通常用来形容多线程之间的相互影响.

5.死锁(dead lock) 饥饿(starvation) 活锁(live lock)
  死锁, 饥饿, 活锁都属于多线程的活跃性问题, 如果发现这些情况, 那么相关线程就不再活跃, 于就是说他可能很难再继续往下执行了.
  死锁: 一组线程被阻塞了, 各个线程都在等待一个永远都不会为真的条件, 它们会一直不会执行而等待下去
  饥饿: 某一个或者多个线程因为种种原因无法获得所需要的资源, 导致一直无法执行, 线程的优先级会引发该问题
  活锁: 线程之间过于秉承"谦让"的原则, 主动将资源释放给别的线程使用, 那么就会出现没有一个线程可以同时拿到所有资源而正常执行


6.并发级别
  由于临界区的存在, 多线程之间的并发必须受到控制.
  根据控制并发的策略, 那可以把并发的级别进行分类, 大致分为: 阻塞, 无饥饿, 无障碍, 无锁, 无等待几种

  6.1 阻塞(blocking)
      在线程执行后续代码前, 线程会试图得到临界区的锁, 如果得不到, 线程会被挂起等待, 直到占有了得到锁进入临界区为止

  6.2 无饥饿(starvation-free)
      线程是有优先级的, 使用公平锁来达到无饥饿的效果

  6.3 无障碍(obstruction-free)
      无障碍是一种最弱的非阻塞调度, 非阻塞调度相对于阻塞调度来说就是一种乐观的策略.

      线程可以随意进入临界区, 如果多个线程一起修改共享数据, 导致数据出错了, 那么,
      对于无障碍的线程来说, 一旦检测到这种情况, 它就会立即对自己所做的修改进行回滚, 确保数据安全,
      但如果没有数据竞争发生, 那么线程就可以顺利完成自己的工作, 走出临界区.

  6.4 无锁(lock-free)
      无锁的并行都是无障碍的, 再无锁的情况下, 所有线程都能尝试对临界区进行访问,
      但不同的是, 无锁的并发保证必然有一个线程能够再有限步内完成操作离开临界区.

      无锁的并行总能保证有1个线程可以胜出而不至于全军覆没, 至于竞争失败的线程, 它们必须不断重试,
      直到自己获胜, 但如果运气不好, 总是尝试不成功, 则会出现类似饥饿的现象, 线程会停滞不前.

  6.5 无等待(wait-free)
      无等待再无锁的基础上更进一步进行扩展, 它要求所有的线程都必须在有限步内完成, 这样就不会引起饥饿问题


7.JMM
  JMM的关键技术点都是围绕着多线程的原子性, 可见性和有序性来建立的.

  7.1 原子性(atomicity)
      原子性是指一个操作是不可中断的, 即一个线程里所执行的一个操作一旦开始, 就不会被其他线程干扰.

  7.2 可见性(visibility)
      可见性是指当一个县城修改了某一个共享变量的值, 其他线程是否能够立即知道这个修改.
      比如: 如果一个线程修改了某一个全局变量, 那么其他线程未必可以马上知道这个改动.

      可见性问题是一个综合问题, 除了缓存优化和硬件优化会导致该问题外, 指令重排以及编辑器的优化也会导致该问题.

  7.3 有序性(ordering)
      有序性问题可能是三个问题中最难理解的, 在并发时, 程序的执行可能就会出现乱序,
      给人的直观感觉就是: 写在前面的代码, 会在后面执行;

      有序性问题的原因是因为程序在执行时, 可能会进行指令重排, 重排后的指令与原指令的顺序未必一致.
      更具体来说就是线程A的指令执行顺序在线程B看来并没有保证的, 但对于一个线程来说, 它看到的指令执行顺序一定是一致的.

      指令重排是有一个基本前提的, 就是保证串行语义的一致性, 所以指令重排不会使穿行的语义逻辑发生问题.

      指令重排对于提高CPU处理性能是十分必要的, 所以它也是合理的存在.



Java并行程序基础
1.进程(process)是计算机中的程序关于某数据集合上的一次运行活动, 是系统进行资源分配和调度的基本单位, 是操作系统的基础结构.
  进程是程序的实体, 一个被安装好的IntelliJ IDEA并且它没有运行, 可以说这是静态的, 而进程指的就是运行该IntelliJ IDEA的时候.

2.进程是线程的容器
  线程就是轻量级进程, 是程序执行的最小单位.
  使用多线程而不是多进程去进行并发程序的设计, 是因为线程间的切换和调度的成本远远小于进程.

3.Java中的线程总共有6种状态
  它们的定义在Thread.State枚举中:
  NEW           新建        已经创建好的线程, 但还没调用start方法开始执行
  RUNNABLE      正在运行    线程正在Java虚拟机上运行, 但这种状态下的线程也有可能是正在等待来自系统(比如处理器)的其他资源.
  BLOCKED       被阻塞      处于阻塞状态的线程正在等待监视器锁以便让线程进入同步块/方法或者在调用后重入同步块/方法
  WAITING       无时限等待  在当前线程调用某些特殊方法可以使得该线程处于等待状态, 该等待直到另一个线程调用某些特殊的方法或结束才结束
  TIMED_WAITING 有时限等待  在当前线程调用某些特殊方法并指定一个时长, 那可以使得该线程等待指定的时长
  TERMINATED    结束

  从NEW状态出发后, 线程不能再回到NEW状态, 同理, 处于TERMINATED状态的线程不能再回到RUNNABLE状态
